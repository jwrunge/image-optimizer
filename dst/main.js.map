{"version":3,"file":"main.js","sources":["../src/main.js"],"sourcesContent":["let sharp = require('sharp')\r\nlet path = require('path')\r\nlet fs = require('fs')\r\n\r\n// List all files in a directory in Node.js recursively in a synchronous fashion\r\nfunction walkSync(dir, filelist, rootDir = dir) {\r\n    let files = fs.readdirSync(dir)\r\n    filelist = filelist || []\r\n\r\n    for(let file of files) {\r\n        let filepath = path.join(dir, file)\r\n        if (fs.statSync(filepath).isDirectory()) {\r\n            filelist = walkSync(filepath, filelist, rootDir)\r\n        }\r\n        else {\r\n            let shortdir = dir.replace(rootDir, '')\r\n            filelist.push(path.join(shortdir, file))\r\n        }\r\n    }\r\n\r\n    return filelist\r\n}\r\n\r\n//Destination is the folder containing the image source folder\r\n//imageFolder is the name of the image folder inside the source folder\r\n//breakpoints is an array of objects with dirnames and image widths as such:\r\n/*\r\n    [\r\n        { dir: 'images-webp-400', size: 400 },\r\n        { dir: 'images-webp-800', size: 800 },\r\n        { dir: 'images-webp-1600', size: 1600 }\r\n    ]\r\n\r\n    creates folders <destination>/images-webp-400 through 1600 and stores images in webp of those sizes\r\n*/\r\nexport function createOptimizationFolders(destination, imageFolder, breakpoints) {\r\n    //Error check here! TODO\r\n\r\n    if(!breakpoints) {\r\n        breakpoints = [\r\n            {dir: path.join(destination, 'images-webp-400'), size: 400},\r\n            {dir: path.join(destination, 'images-webp-800'), size: 800},\r\n            {dir: path.join(destination, 'images-webp-1600'), size: 1600},\r\n            {dir: path.join(destination, 'images-webp-3200'), size: 3200}\r\n        ]\r\n    }\r\n\r\n    //Source folder\r\n    let sourceFolder = path.join(destination, imageFolder)\r\n\r\n    let images = walkSync(sourceFolder)\r\n\r\n    for(let i = 0; i < images.length; i++) {\r\n        let fileName = path.parse(images[i]).name\r\n        let imgExt = path.parse(images[i]).ext\r\n        let fullName = path.basename(images[i])\r\n        let shortPath = images[i].replace(fullName, \"\")\r\n    \r\n        if(['.jpg', '.jpeg', '.png', '.gif', '.webp', '.tiff'].includes(imgExt.toLowerCase())) {\r\n            //Cycle through output folders\r\n            for(let j = 0; j < breakpoints.length; j++) {\r\n                //Create the new directory if it does not exist\r\n                if(!fs.existsSync(path.join(breakpoints[j].dir, shortPath)))\r\n                    fs.mkdirSync(path.join(breakpoints[j].dir, shortPath), { recursive: true })\r\n    \r\n                let outputPath = path.join(breakpoints[j].dir, shortPath, fileName + \".webp\")\r\n                let originalFileUpdated = fs.statSync(path.join(sourceFolder, images[i])).mtime\r\n                let newFileUpdated = fs.statSync(outputPath).mtime\r\n                \r\n                if(!fs.existsSync(outputPath) || originalFileUpdated > newFileUpdated) {\r\n                    sharp(path.join(sourceFolder, images[i]))  \r\n                        .rotate()\r\n                        .resize({ width: breakpoints[j].size, withoutEnlargement: true })\r\n                        .webp()\r\n                        .toFile(outputPath,\r\n                        (err, info)=> {\r\n                            if(err) console.log(images[i] + \": \" + err)\r\n                        })\r\n                }\r\n                else console.log('Skipping existing file ' + path.join(breakpoints[j].dir, shortPath, fileName + \".webp\"))\r\n            }\r\n        }\r\n        else {\r\n            console.log(\"Could not process \" + image[i] + \": filetype not supported.\")\r\n        }\r\n    }\r\n}"],"names":["sharp","require","path","fs","destination","imageFolder","breakpoints","dir","join","size","sourceFolder","images","walkSync","filelist","rootDir","files","readdirSync","file","filepath","statSync","isDirectory","shortdir","replace","push","i","length","fileName","parse","name","imgExt","ext","fullName","basename","shortPath","includes","toLowerCase","j","existsSync","mkdirSync","recursive","outputPath","originalFileUpdated","mtime","newFileUpdated","rotate","resize","width","withoutEnlargement","webp","toFile","err","info","console","log","image"],"mappings":"oEAAA,IAAIA,EAAQC,QAAQ,SAChBC,EAAOD,QAAQ,QACfE,EAAKF,QAAQ,wCAiCV,SAAmCG,EAAaC,EAAaC,GAG5DA,IACAA,EAAc,CACV,CAACC,IAAKL,EAAKM,KAAKJ,EAAa,mBAAoBK,KAAM,KACvD,CAACF,IAAKL,EAAKM,KAAKJ,EAAa,mBAAoBK,KAAM,KACvD,CAACF,IAAKL,EAAKM,KAAKJ,EAAa,oBAAqBK,KAAM,MACxD,CAACF,IAAKL,EAAKM,KAAKJ,EAAa,oBAAqBK,KAAM,YAK5DC,EAAeR,EAAKM,KAAKJ,EAAaC,GAEtCM,EA7CR,SAASC,EAASL,EAAKM,EAAUC,EAAUP,OACnCQ,EAAQZ,EAAGa,YAAYT,GAC3BM,EAAWA,GAAY,OAEnB,IAAII,KAAQF,EAAO,KACfG,EAAWhB,EAAKM,KAAKD,EAAKU,MAC1Bd,EAAGgB,SAASD,GAAUE,cACtBP,EAAWD,EAASM,EAAUL,EAAUC,OAEvC,KACGO,EAAWd,EAAIe,QAAQR,EAAS,IACpCD,EAASU,KAAKrB,EAAKM,KAAKa,EAAUJ,YAInCJ,EA8BMD,CAASF,OAElB,IAAIc,EAAI,EAAGA,EAAIb,EAAOc,OAAQD,IAAK,KAC/BE,EAAWxB,EAAKyB,MAAMhB,EAAOa,IAAII,KACjCC,EAAS3B,EAAKyB,MAAMhB,EAAOa,IAAIM,IAC/BC,EAAW7B,EAAK8B,SAASrB,EAAOa,IAChCS,EAAYtB,EAAOa,GAAGF,QAAQS,EAAU,OAEzC,CAAC,OAAQ,QAAS,OAAQ,OAAQ,QAAS,SAASG,SAASL,EAAOM,mBAE/D,IAAIC,EAAI,EAAGA,EAAI9B,EAAYmB,OAAQW,IAAK,CAEpCjC,EAAGkC,WAAWnC,EAAKM,KAAKF,EAAY8B,GAAG7B,IAAK0B,KAC5C9B,EAAGmC,UAAUpC,EAAKM,KAAKF,EAAY8B,GAAG7B,IAAK0B,GAAY,CAAEM,WAAW,QAEpEC,EAAatC,EAAKM,KAAKF,EAAY8B,GAAG7B,IAAK0B,EAAWP,EAAW,SACjEe,EAAsBtC,EAAGgB,SAASjB,EAAKM,KAAKE,EAAcC,EAAOa,KAAKkB,MACtEC,EAAiBxC,EAAGgB,SAASqB,GAAYE,OAEzCvC,EAAGkC,WAAWG,IAAeC,EAAsBE,EACnD3C,EAAME,EAAKM,KAAKE,EAAcC,EAAOa,KAChCoB,SACAC,OAAO,CAAEC,MAAOxC,EAAY8B,GAAG3B,KAAMsC,oBAAoB,IACzDC,OACAC,OAAOT,EACR,CAACU,EAAKC,KACCD,GAAKE,QAAQC,IAAI1C,EAAOa,GAAK,KAAO0B,KAG9CE,QAAQC,IAAI,0BAA4BnD,EAAKM,KAAKF,EAAY8B,GAAG7B,IAAK0B,EAAWP,EAAW,eAIrG0B,QAAQC,IAAI,qBAAuBC,MAAM9B,GAAK"}